
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБЩЕГО НАЗНАЧЕНИЯ

// Процедура ВызватьИсключениеЕслиНетПраваАдминистрирования вызывает исключение,
// если у пользователя нет права администрирования.
//
Процедура ВызватьИсключениеЕслиНетПраваАдминистрирования()

	ВыполняетсяПроцедураОбработатьРегламентныеЗадания = ХранилищеОбщихНастроек.Загрузить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания");
	Если ТипЗнч(ВыполняетсяПроцедураОбработатьРегламентныеЗадания) <> Тип("Булево") Тогда
		ВыполняетсяПроцедураОбработатьРегламентныеЗадания = Ложь;
	КонецЕсли;
	Если НЕ ВыполняетсяПроцедураОбработатьРегламентныеЗадания И
	     НЕ ПользователиИнформационнойБазы.ПолучитьПользователей().Количество() = 0 И
	     НЕ ПравоДоступа("Администрирование", Метаданные, ПользователиИнформационнойБазы.ТекущийПользователь()) Тогда
		ВызватьИсключение(НСтр("ru = 'У пользователя нет права администрирования!'"));
	КонецЕсли;
	
КонецПроцедуры // ВызватьИсключениеЕслиНетПраваАдминистрирования()

// Процедура ДобавитьВСписокЗначенийИменаПользователей добавляет
// в Список имена пользователей, как они заданы в конфигураторе.
//
// Параметры:
//  Список       - СписокЗначений - обычно СписокВыбора ПоляВвода.
//
Процедура ДобавитьВСписокЗначенийИменаПользователей(Список) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	// Заполним список имен пользователей информационной базы для выбора
	МассивПользователей = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Для каждого Пользователь Из МассивПользователей Цикл
		Список.Добавить(Пользователь.Имя);
	КонецЦикла;

КонецПроцедуры // ДобавитьВСписокЗначенийИменаПользователей()

// Функция ТекущийСеансОбрабатываетЗадания определяет, что текущий сеанс обрабатывает задания,
// если это не так и указано установить текущий сеанс в этом качестве, то производится попытка
// установки.
//
// Параметры:
//  ЗаданияОбрабатываютсяНормально - Булево - Истина, если нет отклонений в выполнении заданий.
//  УстановитьТекущийСеансКакСеансОбрабатывающийЗадания - Булево - Истина, если требуется установить
//               текущий сеанс, как сеанс в котором будет происходить обработка, если не удалось установить,
//               тогда функция вернет Ложь.
//  ОписаниеОшибки - Строка - Если НЕ ЗаданияОбрабатываютсяНормально, тогда описание отклонения:
//               либо обработка долго не стартует, либо долго выполняется.
//
// Возвращаемое значение:
//  Булево.
//
Функция ТекущийСеансОбрабатываетЗадания(ЗаданияОбрабатываютсяНормально = Неопределено,
                                        Знач УстановитьТекущийСеансКакСеансОбрабатывающийЗадания = Ложь,
                                        ОписаниеОшибки = "") Экспорт
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ЗаданияОбрабатываютсяНормально = Истина;
		ОписаниеОшибки = НСтр("ru = 'Задания обрабатываются на сервере!'");
		Возврат Ложь;
	КонецЕсли;
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	НайденСеансОбрабатывающийЗадания = Ложь;
	ТекущийСеансОбрабатываетЗадания  = Ложь;
	ЗаданияОбрабатываютсяНормально   = Истина;
	
	// Найдем сеанс обработки заданий, установленный в константе СостояниеОбработкиРегламентныхЗаданий,
	// среди активных сеансов, и текущий сеанс (начало текущего сеанса может понадобится
	// для инициализации Структуры).
	Для каждого Сеанс Из Сеансы Цикл
		Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
			ТекущийСеанс = Сеанс;
		КонецЕсли;
		Если Сеанс.НомерСеанса 	= Состояние.НомерСеанса
		   И Сеанс.НачалоСеанса = Состояние.НачалоСеанса Тогда
		   	НайденныйСеанс 		= Сеанс;
			НайденСеансОбрабатывающийЗадания = Истина;
			ТекущийСеансОбрабатываетЗадания  = (Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы());
		КонецЕсли;
	КонецЦикла;
	Если НЕ НайденСеансОбрабатывающийЗадания И УстановитьТекущийСеансКакСеансОбрабатывающийЗадания Тогда
		МоментТекущегоВремени                           = ТекущаяДата();
		Состояние.НомерСеанса                           = ТекущийСеанс.НомерСеанса;
		Состояние.НачалоСеанса                          = ТекущийСеанс.НачалоСеанса;
		Состояние.ИмяКомпьютера                         = ИмяКомпьютера();
		Состояние.ИмяПриложения                         = ТекущийСеанс.ИмяПриложения;
		Состояние.ИмяПользователя                       = ИмяПользователя();
		Состояние.ИдентификаторОчередногоЗадания        = Неопределено;
		Состояние.НачалоОбработкиОчередногоЗадания      = МоментТекущегоВремени;
		Состояние.ОкончаниеОбработкиОчередногоЗадания   = МоментТекущегоВремени;
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
		НайденСеансОбрабатывающийЗадания = Истина;
		ТекущийСеансОбрабатываетЗадания  = Истина;
	КонецЕсли;

	Если НЕ НайденСеансОбрабатывающийЗадания Тогда
		ОписаниеОшибки = НСтр("ru = 'Нет сеанса, обрабатывающего регламентные задания!'");
		ЗаданияОбрабатываютсяНормально = Ложь;
	ИначеЕсли Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий Тогда
		ОписаниеОшибки = НСтр("ru = 'Выполнение регламентных заданий заблокировано!'");
		ЗаданияОбрабатываютсяНормально = Ложь;
	ИначеЕсли НЕ ЗначениеЗаполнено(Состояние.ОкончаниеОбработкиОчередногоЗадания) Тогда
		// Если после завершения очередного задания прошло более часа, значит задержка запуска.
		Если ТекущаяДата() - 360 > Состояние.ОкончаниеОбработкиОчередногоЗадания Тогда
			ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Запуск обработки регламентных заданий задерживается более 1 часа!
			                                                                                    |Возможно требуется проверка и перезапуск сеанса. Запуск ожидается
			                                                                                    |    на компьютере:         %1,
			                                                                                    |    в приложении:          %2,
			                                                                                    |    от имени пользователя: %3,
			                                                                                    |    в сеансе номер:        %4.'"),
			                                                                         Строка(Состояние.ИмяКомпьютера),
			                                                                         Строка(Состояние.ИмяПриложения),
			                                                                         Строка(Состояние.ИмяПользователя),
			                                                                         Строка(Состояние.НомерСеанса) );
			ЗаданияОбрабатываютсяНормально = Ложь;
		КонецЕсли;
	
	Иначе
		// Если обработка продолжается более 1 часа, значить она слишком затянулась.
		Если ТекущаяДата() - 360 > Состояние.НачалоОбработкиОчередногоЗадания Тогда
			ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Обработка регламентного задания выполняется непрерывно уже более 1 часа!
			                                                                                    |Возможно требуется проверка и перезапуск сеанса. Выполнение происходит
			                                                                                    |    на компьютере:         %1,
			                                                                                    |    в приложении:          %2,
			                                                                                    |    от имени пользователя: %3,
			                                                                                    |    в сеансе номер:        %4.'"),
			                                                                         Строка(Состояние.ИмяКомпьютера),
			                                                                         Строка(Состояние.ИмяПриложения),
			                                                                         Строка(Состояние.ИмяПользователя),
			                                                                         Строка(Состояние.НомерСеанса));
			ЗаданияОбрабатываютсяНормально = Ложь;
		КонецЕсли;
	КонецЕсли;
	Возврат ТекущийСеансОбрабатываетЗадания;
	
КонецФункции // ТекущийСеансОбрабатываетЗадания()

// Функция РодительскийСеансЗаданИЗавершен проверяет,
// что сеанс открывший этот дополнительный сеанс для обработки
// регламентных заданий завершен, если задан.
//
// Параметры:
//  ПараметрЗапуска - Строка - значение глобального свойства ПараметрЗапуска,
//                 требуется указывать, т.к. свойство недоступно на сервере.
//  РодительскийСеансЗадан - Булево - возвращает Истина, если родительский сеанс задан,
//                 иначе возвращает Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция РодительскийСеансЗаданИЗавершен(Знач ПараметрЗапуска) Экспорт

	РодительскийСеансЗадан = Ложь;
	Если Найти(ПараметрЗапуска, "DoScheduledJobs") <> 0 Тогда
		ИндексНомераСеанса = Найти(ПараметрЗапуска, "SessionNumber=");
		ИндексНачалаСеанса = Найти(ПараметрЗапуска, "SessionStarted=");
		Если ИндексНомераСеанса <> 0 И
		     ИндексНачалаСеанса <> 0 И
		     ИндексНомераСеанса < ИндексНачалаСеанса Тогда
			РодительскийСеансЗадан = Истина;
		    Сеансы = ПолучитьСеансыИнформационнойБазы();
			Для каждого Сеанс Из Сеансы Цикл
				Если Найти(ПараметрЗапуска, "SessionNumber="  + Сеанс.НомерСеанса)  <> 0 И
				     Найти(ПараметрЗапуска, "SessionStarted=" + Сеанс.НачалоСеанса) <> 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // РодительскийСеансЗаданИЗавершен()

////////////////////////////////////////////////////////////////////////////////
// ЭКСПРОТНЫЕ МЕТОДЫ РАСШИРЕНИЯ МЕНЕДЖЕРА РЕГЛАМЕНТНЫХ ЗАДАНИЙ
//

// Процедура ОбработатьРегламентныеЗадания() эмулирует в тонком клиенте
// системную процедуру ВыполнитьОбработкуЗаданий(), но может применяться и
// в толстом клиенте.
//
//  Место хранения экземпляров фоновых заданий - ВременноеХранилище.
// Время хранения экземпляров - до закрытия сеанса клиента, выполняющего обработку.
// Максимальное количество одновременно хранимых фоновых заданий: 1000.
//
//  Идентификатор сеанса, выполняющего обработку находится в константе
// СостояниеОбработкиРегламентныхЗаданий (ХранилищеЗначения), содержащее структуру
// со свойствами: 
// НомерСеанса, НачалоСеанса, ИдентификаторОчередногоЗадания,
// НачалоОбработкиОчередногоЗадания, ОкончаниеОбработкиОчередногоЗадания и др.
//  Логика проверки на выполнение обработки заданий именно в текущем сеансе:
// Если <НомерСеанса> и  <НачалоСеанса> совпадают с текущим,
// Тогда выполняем, если нет, тогда проверяем существует ли сеанс в списке сеансов,
// если не существует, тогда выполняем, если существует тогда не выполняем, но
// проверяем период выполнения/простоя. Если "выполняется"/"простаивает" дольше
// 1 час будем уведомлять пользователя (ошибка с соответствующим описанием).
//  Логика порядка выполнения заданий. Задания выполняются последовательно,
// регистрируется последнее запущенное задание. При новой проверке, проверяемым
// заданием будет задание, следующее за запущенным. 
//  Логика проверки расписания. Если произошла ошибка тогда используется аварийное
// расписание, иначе - основное.
// 
// Параметры:
//  ВремяОбработки - Число(10.0) - Время в секундах обработки очередной
//                 порции заданий. Если время не задано, будет выполнен
//                 только один цикл обработки (до завершения одного фонового
//                 задания или обработки всех регламентных заданий).
//
// Возвращаемое значение:
//  Булево       - НЕ Отказ.
//
Процедура ОбработатьРегламентныеЗадания(ВремяОбработки = 0, УведомлятьПользователя = Ложь) Экспорт
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Возврат;
	КонецЕсли;

	Если НЕ ТекущийСеансОбрабатываетЗадания() Тогда
		Возврат;
	КонецЕсли;
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	Если Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий Тогда
		Возврат;
	КонецЕсли;

	// Разрешаем вызов привилегированных функций на время выполнения этой процедуры.
	ХранилищеОбщихНастроек.Сохранить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания", , Истина);
	
	ВремяОбработки = ?(ТипЗнч(ВремяОбработки) = Тип("Число"), ВремяОбработки, 0);

	Задания                        = РегламентныеЗадания.ПолучитьРегламентныеЗадания();
	ОбработкаЗавершена             = Ложь; // Определяет, что ВремяОбработки закончилось, или
	                                       // все возможные задания обработаны.
	НачалоОбработки                = ТекущаяДата();
	КоличествоОбработанныхЗаданий  = 0;
	ФоновоеЗаданиеВыполнялось      = Ложь;
	ИдентификаторПоследнегоЗадания = Состояние.ИдентификаторОчередногоЗадания;

	// Количество заданий будем проверять каждый раз при запуске обработки,
	// т.к. они могут быть удалены в другом сеансе, а тогда будет зацикливание.
	Пока НЕ ОбработкаЗавершена И Задания.Количество() > 0 Цикл
		ПервоеЗаданиеНайдено           = (ИдентификаторПоследнегоЗадания = Неопределено);
		ОчередноеЗаданиеНайдено        = Ложь;
		Для каждого Задание ИЗ Задания Цикл
			// Завершаем обработку, если:
			// а) время задано и вышло;
			// б) время не задано и хоть одно фоновое задание выполнено;
			// в) время не задано и все регламентные задания обработаны по количеству.
			Если ( ВремяОбработки = 0 И
			       ( ФоновоеЗаданиеВыполнялось ИЛИ
			         КоличествоОбработанныхЗаданий >= Задания.Количество() ) ) ИЛИ
			     ( ВремяОбработки <> 0 И
			       НачалоОбработки + ВремяОбработки <= ТекущаяДата() ) Тогда
				ОбработкаЗавершена = Истина;
				Прервать;
			КонецЕсли;
			Если НЕ ПервоеЗаданиеНайдено Тогда
				Если Строка(Задание.УникальныйИдентификатор) = ИдентификаторПоследнегоЗадания Тогда
				   // Найдено последнее обработанное задание, значит следующее
				   // задание нужно проверять на необходимость обработки.
				   ПервоеЗаданиеНайдено = Истина;
				КонецЕсли;
				// Если первое задание, которое нужно проверить на необходимость
				// запуска ещё не найдено, тогда пропускаем текущее задание.
				Продолжить;
			КонецЕсли;
			ОчередноеЗаданиеНайдено = Истина;
			КоличествоОбработанныхЗаданий = КоличествоОбработанныхЗаданий + 1;
			Состояние.ИдентификаторОчередногоЗадания      = Строка(Задание.УникальныйИдентификатор);
			Состояние.НачалоОбработкиОчередногоЗадания    = ТекущаяДата();
			Состояние.ОкончаниеОбработкиОчередногоЗадания = '00010101';
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
			Если Задание.Использование Тогда
				ОбработатьРегламентноеЗадание = Ложь;
				СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(Задание);
				
				Если СвойстваПоследнегоФоновогоЗадания <> Неопределено И
				     СвойстваПоследнегоФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
					// Проверка аварийного расписания.
					Если СвойстваПоследнегоФоновогоЗадания.ПопыткаЗапуска <= Задание.КоличествоПовторовПриАварийномЗавершении Тогда
						Если СвойстваПоследнегоФоновогоЗадания.Конец + Задание.ИнтервалПовтораПриАварийномЗавершении <= ТекущаяДата() Тогда
						    // Повторный запуск фонового задания по регламентному заданию.
						    ОбработатьРегламентноеЗадание = Истина;
						КонецЕсли;
					КонецЕсли;
				Иначе
					// Проверяем стандартное расписание.
					ОбработатьРегламентноеЗадание = Задание.Расписание.ТребуетсяВыполнение(
						ТекущаяДата(),
						?(СвойстваПоследнегоФоновогоЗадания = Неопределено, '00010101', СвойстваПоследнегоФоновогоЗадания.Начало),
						?(СвойстваПоследнегоФоновогоЗадания = Неопределено, '00010101', СвойстваПоследнегоФоновогоЗадания.Конец ));
				КонецЕсли;
				Если ОбработатьРегламентноеЗадание Тогда
					ОбработатьРегламентноеЗадание(Состояние, Задание);
					ФоновоеЗаданиеВыполнялось = Истина;
				КонецЕсли;
			КонецЕсли;
			Состояние.ОкончаниеОбработкиОчередногоЗадания = ТекущаяДата();
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
		КонецЦикла;
		// Если последнее выполненное задание найти не удалось, тогда
		// сбросим его Идентификатор, чтобы начать проверку регламентных заданий с первого.
		ИдентификаторПоследнегоЗадания = Неопределено;
	КонецЦикла;
	
	// Запрещаем вызов привилегированных функций после выполнения этой процедуры.
	ХранилищеОбщихНастроек.Сохранить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания", , Ложь);
	
КонецПроцедуры // ОбработатьРегламентныеЗадания()

// Процедура УстановитьНастройкиОбработкиРегламентныхЗаданий устанавливает
// настройки для файлового режима обработки заданий.
// 
// Параметры:
//  Настройки - Структура.
//
Процедура УстановитьНастройкиОбработкиРегламентныхЗаданий(Настройки) Экспорт

	Если НЕ ПроверитьНастройки(Настройки) Тогда
		ВызватьИсключение(НСтр("ru = 'Неверные параметры процедуры НастройкиОбработкиРегламентныхЗаданий!'"));
	КонецЕсли;
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("Константа.СостояниеОбработкиРегламентныхЗаданий");
		Элемент.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
		Если Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий <> Настройки.БлокировкаОбработкиРегламентныхЗаданий ИЛИ
			 Состояние.Настройки.ИмяПользователяДляЗапуска              <> Настройки.ИмяПользователяДляЗапуска ИЛИ
			 Состояние.Настройки.ПарольПользователяДляЗапуска           <> Настройки.ПарольПользователяДляЗапуска Тогда
			ВызватьИсключениеЕслиНетПраваАдминистрирования();
		КонецЕсли;
		Состояние.Настройки = Настройки;
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние, Истина);
		ЗафиксироватьТранзакцию();
	Исключение
		ОписаниеОшибки = ОписаниеОшибки();
		ОтменитьТранзакцию();
		ВызватьИсключение(ОписаниеОшибки);
	КонецПопытки;
	
КонецПроцедуры // УстановитьНастройкиОбработкиРегламентныхЗаданий()

// Процедура ПолучитьНастройкиОбработкиРегламентныхЗаданий получает настройки
// для файлового режима обработки заданий.
// 
// Возвращаемое значение:
//  Настройки - Структура.
//
Функция ПолучитьНастройкиОбработкиРегламентныхЗаданий() Экспорт

	Настройки = ПолучитьСостояниеОбработкиРегламентныхЗаданий().Настройки;
	ПроверитьНастройки(Настройки, Истина);
	Возврат Настройки;
	
КонецФункции // ПолучитьНастройкиОбработкиРегламентныхЗаданий()

// Функция возвращает представление регламентного задания,
// это по порядку исключения незаполненных реквизитов:
// Наименование, Метаданные.Синоним, Метаданные.Имя.
//
// Параметры:
//  Задание      - РегламентноеЗадание, Строка - если строка, тогда УникальныйИдентификатор строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПредставлениеРегламентногоЗадания(Знач Задание) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Если ТипЗнч(Задание) = Тип("РегламентноеЗадание") Тогда
		РегламентноеЗадание = Задание;
	Иначе
		РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(Задание));
	КонецЕсли;
	
	Если РегламентноеЗадание <> Неопределено Тогда
		Представление = РегламентноеЗадание.Наименование;
		Если ПустаяСтрока(РегламентноеЗадание.Наименование) Тогда
			// Применим синоним вместо наименования
			Представление = РегламентноеЗадание.Метаданные.Синоним;
			Если ПустаяСтрока(Представление) Тогда
				// Применим имя вместо синонима
				Представление = РегламентноеЗадание.Метаданные.Имя;
			КонецЕсли
		КонецЕсли;
	Иначе
		Представление = ТекстНеОпределено();
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции // ПредставлениеРегламентногоЗадания()

// Служебная функция, возвращающая текст "<не определено>" с локализацией.
// Используется для целей локализации
//
Функция ТекстНеОпределено() Экспорт
	
	Возврат НСтр("ru = '<не определено>'");
	
КонецФункции

// Функция ПолучитьРегламентноеЗадание получает РегламентноеЗадание из информационной
// базы по строке уникального идентификатора.
//
// Параметры:
//  Идентификатор - Строка уникального идентификатора РегламентногоЗадания.
// 
// Возвращаемое значение:
//  РегламентноеЗадание.
//
Функция ПолучитьРегламентноеЗадание(Знач Идентификатор) Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(Идентификатор));
	
	Если РегламентноеЗадание = Неопределено Тогда
		ВызватьИсключение( НСтр("ru = 'Задание не найдено в списке!
		                              |Возможно, оно удалено другим пользователем!'") );
	КонецЕсли;
	
	Возврат РегламентноеЗадание;
	
КонецФункции // ПолучитьРегламентноеЗадание()

// Процедура ОбработатьРегламентноеЗаданиеВручную предназначена для
// "ручного" немедленного выполнения процедуры регламентного задания
// либо в сеансе клиента (в файловой ИБ), либо в фоновом задании на сервере (в серверной ИБ).
// Применяется в любом режиме соединения.
// "Ручной" режим запуска не влияет на выполнение регламентного задания по аварийному
// и основному расписаниям, т.к. не указывается ссылка на регламентное задание у фонового задания.
// Тип ФоновоеЗадание не допускает установки такой ссылки, поэтому для файлового режима применяется
// тоже правило.
// 
// Параметры:
//  Задание       - РегламентноеЗадание, Строка уникального идентификатора РегламентногоЗадания.
//  МоментЗапуска - Неопределено, Дата(дата и время). Для файловой ИБ устанавливает переданный
//                 момент, как момент запуска. Для серверной ИБ - возвращает момент запуска 
//                 фонового задания по факту.
//  ИдентификаторФоновогоЗадания - Строка - идентификатор запущенного фонового задания.
//
//
Процедура ОбработатьРегламентноеЗаданиеВручную(Знач Задание,
                                               МоментЗапуска = Неопределено,
                                               ИдентификаторФоновогоЗадания = "") Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Задание = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Задание, ПолучитьРегламентноеЗадание(Задание));
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ОбработатьРегламентноеЗадание(Состояние, Задание, Истина, МоментЗапуска, ИдентификаторФоновогоЗадания);
		// Обновление состояния уже выполнено в вызванной процедуре.
	Иначе
		НаименованиеФоновогоЗадания = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Запуск вручную: %1'"), ПредставлениеРегламентногоЗадания(Задание));
		ФоновоеЗадание = ФоновыеЗадания.Выполнить(Задание.Метаданные.ИмяМетода, Задание.Параметры, Задание.Ключ, НаименованиеФоновогоЗадания);
		ИдентификаторФоновогоЗадания = Строка(ФоновоеЗадание.УникальныйИдентификатор);
		Состояние.Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную.Вставить( ИдентификаторФоновогоЗадания, Строка(Задание.УникальныйИдентификатор) );
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ФоновоеЗадание.УникальныйИдентификатор);
		МоментЗапуска  = ФоновоеЗадание.Начало;
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	КонецЕсли;
	
КонецПроцедуры // ОбработатьРегламентноеЗаданиеВручную()

// Функция НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий возвращает
// значение флажка настройки обработки регламентных заданий.
//
// Возвращаемое значение:
//  Булево.
//
Функция НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий(ПериодУведомления) Экспорт

	УведомлятьОНекорректномСостоянии = Ложь;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
		ПериодУведомления = Состояние.Настройки.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий;
		ПериодУведомления = ?(ПериодУведомления <= 0, 1, ПериодУведомления);
		УведомлятьОНекорректномСостоянии = Состояние.Настройки.УведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий;
	Иначе
		ПериодУведомления = 1;
	КонецЕсли;
	
	Возврат УведомлятьОНекорректномСостоянии;
	
КонецФункции // НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий()

// Функция СообщенияИОписанияОшибокРегламентногоЗадания возвращает
// многострочную Строку содержащую Сообщения и ОписаниеИнформацииОбОшибке,
// последнее фоновое задание найдено по идентификатору регламентного задания
// и сообщения/ошибки есть.
//
// Параметры:
//  Задание      - РегламентноеЗадание, Строка - УникальныйИдентификатор
//                 РегламентногоЗадания строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция СообщенияИОписанияОшибокРегламентногоЗадания(Знач Задание) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	ИдентификаторРегламентногоЗадания = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Строка(Задание.УникальныйИдентификатор), Задание);
	СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(ИдентификаторРегламентногоЗадания);
	Возврат ?(СвойстваПоследнегоФоновогоЗадания = Неопределено,
	          "",
	          СообщенияИОписанияОшибокФоновогоЗадания(СвойстваПоследнегоФоновогоЗадания.Идентификатор) );
	
КонецФункции // СообщенияИОписанияОшибокРегламентногоЗадания()

// Возвращает параметры открытия сеанса обработки регламентных заданий.
//
// Параметры:
//  ПоНастройкеАвтооткрытия - Булево - открывать сеанс, если настроено выполнять
//                 автоматическое открытие и не серверная ИБ и не Веб-клиент и
//                 сеанс уже не открыт. В других случаях устанавливается Отказ.
//
// Возвращаемое значение:
//  Структура -    ТребуетсяОткрытьОтдельныйСеанс            - Булево - Истина.
//                 СтрокаЗапуска                             - Строка - строку команды ОС Windows для
//                                                             открытия сеанса обработки регламентных заданий.
//                 ВыполненаПопыткаОткрытия                  - Булево - Ложь, для использования в вызывающей процедуре.
//                 УведомлятьОНекорректномСостоянииОбработки - Булево.
//                 ПериодУведомления                         - Число.
//                 Отказ                                     - Булево.
//                 ОписаниеОшибки                            - Строка.
//
Функция ПараметрыОткрытияСеансаОбработкиРегламентныхЗаданий(Знач ПоНастройкеАвтооткрытия = Ложь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТребуетсяОткрытьОтдельныйСеанс", Ложь);
	Результат.Вставить("ВыполненаПопыткаОткрытия", Ложь);
	Результат.Вставить("СтрокаЗапуска", "");
	Результат.Вставить("УведомлятьОНекорректномСостоянииОбработки", Ложь);
	Результат.Вставить("ПериодУведомления", Неопределено);
	Результат.Вставить("Отказ", Ложь);
	Результат.Вставить("ОписаниеОшибки", "");
	
	Результат.УведомлятьОНекорректномСостоянииОбработки = НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий(Результат.ПериодУведомления);
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	
	Если ПоНастройкеАвтооткрытия И НЕ Состояние.Настройки.АвтоматическиОткрыватьОтдельныйСеансОбработкиРегламентныхЗаданий Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Если ПоНастройкеАвтооткрытия Тогда
			Возврат Результат;
		Иначе
			Результат.Отказ = Истина;
			Результат.ОписаниеОшибки = НСтр("ru = 'Регламентные задания обрабатываются на сервере!'");
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;

	ЗаданияОбрабатываютсяНормально = Неопределено;
	ТекущийСеансОбрабатываетЗадания(ЗаданияОбрабатываютсяНормально);
	Если ЗаданияОбрабатываютсяНормально Тогда
		Если ПоНастройкеАвтооткрытия Тогда
			Возврат Результат;
		Иначе
			Результат.Отказ = Истина;
			Результат.ОписаниеОшибки = НСтр("ru = 'Сеанс, выполняющий регламентные задания, уже открыт!'");
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	ПолноеИмяФайлаПриложения = КаталогПрограммы() + "1cv8c.exe";
	Файл = Новый Файл(ПолноеИмяФайлаПриложения);
	Если НЕ Файл.Существует() Тогда
		Результат.Отказ = Истина;
		Результат.ОписаниеОшибки = НСтр("ru = 'Файл приложения не найден!'");
		Возврат Результат;
	КонецЕсли;
	
	ИмяПользователя    = СокрЛП(Состояние.Настройки.ИмяПользователяДляЗапуска);
	ПарольПользователя = СокрЛП(Состояние.Настройки.ПарольПользователяДляЗапуска);
	Если ПустаяСтрока(ИмяПользователя) Тогда
		ПарольПользователя = "";
	КонецЕсли;
	НомерТекущегоСеанса = НомерСеансаИнформационнойБазы();
	// Определим начало текущего сеанса.
	НачалоТекущегоСеанса = '00010101';
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	Для каждого Сеанс Из Сеансы Цикл
		Если Сеанс.НомерСеанса = НомерТекущегоСеанса Тогда
			НачалоТекущегоСеанса = Сеанс.НачалоСеанса;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Результат.СтрокаЗапуска = """"
		+ ПолноеИмяФайлаПриложения
		+ """ ENTERPRISE /IBConnectionString"""
		+ СтрЗаменить(СтрокаСоединенияИнформационнойБазы(), """", """""") + """"
		+ ?(ПустаяСтрока(ИмяПользователя),    "", " /N""" + ИмяПользователя + """")
		+ ?(ПустаяСтрока(ПарольПользователя), "", " /P""" + ПарольПользователя + """")
		+ " /C""DoScheduledJobs SkipMessageBox AloneIBSession "
		+ "SessionNumber=" + НомерТекущегоСеанса + " SessionStarted=" + НачалоТекущегоСеанса + """";
	
	Результат.ТребуетсяОткрытьОтдельныйСеанс = Истина;
	
	Возврат Результат;
	
КонецФункции // ПараметрыОткрытияСеансаОбработкиРегламентныхЗаданий()

Функция ПолучитьРасписаниеРегламентногоЗадания(Знач Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Возврат ПолучитьРегламентноеЗадание(Идентификатор).Расписание;
	
КонецФункции

Процедура УстановитьРасписаниеРегламентногоЗадания(Знач Идентификатор, Знач Расписание) Экспорт
	
	Задание = РегламентныеЗаданияПолныеПрава.ПолучитьРегламентноеЗадание(Идентификатор);
	Задание.Расписание = Расписание;
	Задание.Записать();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ МЕТОДЫ ОБОБЩЕННОГО МЕНЕДЖЕРА ФОНОВЫХ ЗАДАНИЙ
//
// Обобщенный менеджер фоновых заданий работает как файловом, так и серверном режиме
// эксплуатации информационной базы.

// Функция ПолучитьТаблицуСвойствФоновыхЗаданий() "эмулирует" функцию
// ФоновыеЗадания.ПолучитьФоновыеЗадания() для любого режима соединения.
//  Структуру таблицы  смотри в функции ПроверитьТаблицуФоновыхЗаданий().
// 
// Параметры:
//  Отбор        - Структура - допустимые поля:
//                 УникальныйИдентификатор, Ключ, Состояние, Начало, Конец,
//                 Наименование, ИмяМетода, РегламентноеЗадание. 
//  ВсегоЗаданий - Число - возвращает общее количество заданий без учета отбора.
//
// Возвращаемое значение:
//  ТаблицаЗначений  - возвращается таблица после отбора.
//
Функция ПолучитьТаблицуСвойствФоновыхЗаданий(Отбор = Неопределено, ВсегоЗаданий = 0) Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	ТаблицаОбновлена = НЕ ПроверитьТаблицуФоновыхЗаданий(Состояние.ТаблицаФоновыхЗаданий);
	Таблица = Состояние.ТаблицаФоновыхЗаданий;
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		// Дополним таблицу фоновых заданий.
		// 1. Определим момент с которого нужно дополнять.
		//    Для этого найдем первое активное задание, выполняемое на сервере.
		//    Если такового нет, тогда последнее задание выполняемое на сервере.
		//    Дата начала его выполнения и будет началом периода.
		СтрокиАктивных = Таблица.НайтиСтроки(Новый Структура("НаСервере, Состояние", Истина, СостояниеФоновогоЗадания.Активно));
		Начало = Неопределено;
		Если СтрокиАктивных.Количество() <> 0 Тогда
			// Выберем минимальную дату начала.
			Начало = СтрокиАктивных[0].Начало;
			Для каждого Строка Из СтрокиАктивных Цикл
				Начало = ?(Строка.Начало < Начало, Строка.Начало, Начало);
			КонецЦикла;
		Иначе
			ПоследняяСтрока = Таблица.Найти(Истина, "НаСервере");
			Если ПоследняяСтрока <> Неопределено Тогда
				Начало = ПоследняяСтрока.Начало;
			КонецЕсли;
		КонецЕсли;
		Если Начало = Неопределено Тогда
			ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания();
		Иначе
			ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Начало", Начало));
		КонецЕсли;
		
		// 2. Обновим совпадающие и вставим новые фоновые задания.
		//    Считаем, что список заданий отсортирован по убыванию колонки Начало.
		// 2.1. По ходу цикла проверим, что все задания в таблице со статусом Активно были получены с сервера.
		//      Если на сервере их уже по какой-то причине нет, тогда устанавливаем статус: Завершено.
		АктивныеЗадания = Таблица.НайтиСтроки(Новый Структура("Состояние", СостояниеФоновогоЗадания.Активно));
		НомерЗадания = ТекущиеФоновыеЗадания.Количество() - 1;
		Пока НомерЗадания >= 0 Цикл
			Задание = ТекущиеФоновыеЗадания[НомерЗадания];
			НайденныеСтроки = Таблица.НайтиСтроки(Новый Структура("Идентификатор, Начало", Строка(Задание.УникальныйИдентификатор), Задание.Начало));
			Если НайденныеСтроки.Количество() = 0 Тогда
				Строка = Таблица.Вставить(0);
				ТаблицаОбновлена = Истина;
			Иначе
				Строка = НайденныеСтроки[0];
				Если Строка.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
					// Не имеет смысла обновлять те неактивные задания, которые уже
					// есть в таблице. Они попали в список повторно.
					НомерЗадания = НомерЗадания - 1;
					Продолжить;
				КонецЕсли;
				ТаблицаОбновлена = Истина;
				// Проверка активных задач в таблице, удаленных на сервере, путем удаления найденных из списка.
				АктивныеЗадания.Удалить(АктивныеЗадания.Найти(Строка));
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(Строка, Задание);
			Строка.НаСервере = Истина;
			Строка.Идентификатор = Задание.УникальныйИдентификатор;
			Строка.ИдентификаторРегламентногоЗадания = ?(Задание.РегламентноеЗадание = Неопределено,
														  // Может быть уже установлен, если была обработка вручную.
														 Строка.ИдентификаторРегламентногоЗадания,
														 Задание.РегламентноеЗадание.УникальныйИдентификатор);
			Строка.ОписаниеИнформацииОбОшибке = ?(Задание.ИнформацияОбОшибке = Неопределено, "", ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
			НомерЗадания = НомерЗадания - 1;
		КонецЦикла;
		// 2.3. Сбросим состояние Активно для активных заданий в таблице, но не найденных на сервере.
		ТаблицаОбновлена = ТаблицаОбновлена ИЛИ АктивныеЗадания.Количество() > 0;
		Для каждого ПотерянноеАктивноеЗадание Из АктивныеЗадания Цикл
			ПотерянноеАктивноеЗадание.Состояние = СостояниеФоновогоЗадания.Завершено;
		КонецЦикла;
		
		// 3. Установим идентификаторы регламентных заданий тем фоновым заданиям, которые были выполнены вручную.
		//    И удалим несуществующие (устаревшие) соответствия.
		ЗапущенныеВручную = Состояние.Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную;
		ТаблицаОбновлена = ТаблицаОбновлена ИЛИ ЗапущенныеВручную.Количество() > 0;
		
		МассивКлючейУдалить = Новый Массив;
		Для каждого КлючИЗначение из ЗапущенныеВручную Цикл
			Строка = Таблица.Найти(КлючИЗначение.Ключ, "Идентификатор");
			Если Строка = Неопределено Тогда
				МассивКлючейУдалить.Добавить(КлючИЗначение.Ключ);
			Иначе
				Строка.ИдентификаторРегламентногоЗадания = КлючИЗначение.Значение;
			КонецЕсли;
		КонецЦикла;
		Для каждого Ключ Из МассивКлючейУдалить Цикл
			ЗапущенныеВручную.Удалить(Ключ);
		КонецЦикла;

	КонецЕсли;
	// Почистим лишние задания (больше 1000).
	НомерЗадания = Таблица.Количество()-1;
	Пока НомерЗадания >= 1000 Цикл
		Таблица.Удалить(НомерЗадания);
		НомерЗадания = НомерЗадания - 1;
	КонецЦикла;
	Если ТаблицаОбновлена Тогда
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	КонецЕсли;
	ВсегоЗаданий = Таблица.Количество();
	
	// Выполним Отбор.
	Если Отбор <> Неопределено Тогда
		Начало 	  = Неопределено;
		Конец 	  = Неопределено;
		Состояние = Неопределено;
		Если Отбор.Свойство("Начало") Тогда
			Начало = ?(ЗначениеЗаполнено(Отбор.Начало), Отбор.Начало, Неопределено);
			Отбор.Удалить("Начало");
		КонецЕсли;
		Если Отбор.Свойство("Конец") Тогда
			Конец = ?(ЗначениеЗаполнено(Отбор.Конец), Отбор.Конец, Неопределено);
			Отбор.Удалить("Конец");
		КонецЕсли;
		Если Отбор.Свойство("Состояние") Тогда
			Если ТипЗнч(Отбор.Состояние) = Тип("Массив") Тогда
				Состояние = Отбор.Состояние;
				Отбор.Удалить("Состояние");
			КонецЕсли;
		КонецЕсли;
		Если Отбор.Количество() <> 0 Тогда
			Строки = Таблица.НайтиСтроки(Отбор);
		Иначе
			Строки = Таблица;
		КонецЕсли;
		// Выполним дополнительный фильтр по периоду и состоянию (если отбор определен).
		НомерЭлемента = Строки.Количество() - 1;
		Пока НомерЭлемента >= 0 Цикл
			Если Начало    <> Неопределено И Начало > Строки[НомерЭлемента].Начало ИЛИ
				 Конец     <> Неопределено И Конец  < ?(ЗначениеЗаполнено(Строки[НомерЭлемента].Конец), Строки[НомерЭлемента].Конец, ТекущаяДата()) ИЛИ
				 Состояние <> Неопределено И Состояние.Найти(Строки[НомерЭлемента].Состояние) = Неопределено Тогда
				Строки.Удалить(НомерЭлемента);
			КонецЕсли;
			НомерЭлемента = НомерЭлемента - 1;
		КонецЦикла;
		// Удалим лишние строки из таблицы.
		Если ТипЗнч(Строки) = Тип("Массив") Тогда
			НомерСтроки = ВсегоЗаданий - 1;
			Пока НомерСтроки >= 0 Цикл
				Если Строки.Найти(Таблица[НомерСтроки]) = Неопределено Тогда
					Таблица.Удалить(Таблица[НомерСтроки]);
				КонецЕсли;
				НомерСтроки = НомерСтроки - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции // ПолучитьТаблицуСвойствФоновыхЗаданий()

// Функция возвращает свойства ФоновогоЗадания по строке уникального идентификатора.
//
// Параметры:
//  Идентификатор - Строка - уникального идентификатора ФоновогоЗадания.
//  ИменаСвойств  - Строка, если заполнено, возвращается структура с указанными свойствами.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Структура - свойства ФоновогоЗадания.
//
Функция ПолучитьСвойстваФоновогоЗадания(Идентификатор, ИменаСвойств = "") Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Отбор = Новый Структура("Идентификатор", Идентификатор);
	ТаблицаСвойствФоновыхЗаданий = ПолучитьТаблицуСвойствФоновыхЗаданий(Отбор);
	
	Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
		ВызватьИсключение( НСтр("ru = 'Фоновое задание не найдено!'") );
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИменаСвойств) Тогда
		Результат = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(Результат, ТаблицаСвойствФоновыхЗаданий[0]);
	Иначе
		Результат = ТаблицаСвойствФоновыхЗаданий[0];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьСвойстваФоновогоЗадания()

// Функция ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания возвращает
// свойства последнего фонового задания выполненного по регламентного заданию, если оно есть.
// Процедура работает, как в файл-серверном, так и в клиент-серверном режимах.
//
// Параметры:
//  РегламентноеЗадание - РегламентноеЗадание, Строка - строка уникального идентификатора РегламентногоЗадания.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Неопределено.
//
Функция ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(РегламентноеЗадание) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	ИдентификаторРегламентногоЗадания = ?(ТипЗнч(РегламентноеЗадание) = Тип("РегламентноеЗадание"), Строка(РегламентноеЗадание.УникальныйИдентификатор), РегламентноеЗадание);
	ТаблицаСвойствФоновыхЗаданий = ПолучитьТаблицуСвойствФоновыхЗаданий(Новый Структура("ИдентификаторРегламентногоЗадания", ИдентификаторРегламентногоЗадания));
	ТаблицаСвойствФоновыхЗаданий.Сортировать("Конец Возр");
	
	Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
		СвойстваФоновогоЗадания = Неопределено;
	ИначеЕсли НЕ ЗначениеЗаполнено(ТаблицаСвойствФоновыхЗаданий[0].Конец) Тогда
		СвойстваФоновогоЗадания = ТаблицаСвойствФоновыхЗаданий[0];
	Иначе
		СвойстваФоновогоЗадания = ТаблицаСвойствФоновыхЗаданий[ТаблицаСвойствФоновыхЗаданий.Количество()-1];
	КонецЕсли;
	
	Возврат СвойстваФоновогоЗадания;
	
КонецФункции // ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания()

// Процедура ОтменитьФоновоеЗадание отменяет фоновое задание, если
// это возможно, а именно, если оно выполняется на сервере, и активно.
//
// Параметры:
//  Идентификатор  - Строка уникального идентификатора ФоновогоЗадания.
// 
// Возвращаемое значение:
//  Булево       - НЕ Отказ.
//
Процедура ОтменитьФоновоеЗадание(Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Задание = Неопределено;
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ВызватьИсключение( НСтр("ru ='Действие возможно только для серверной информационной базы!
		                             |Невозможно отменить фоновое задание,
		                             |выполняемое в сеансе файловой информационной базы!
		                             |
		                             |Если фоновое задание выполняется слишком долго и его нужно 
		                             |непременно прекратить, закройте сеанс, в котором
		                             |обрабатываются регламентные задания.
		                             |
		                             |Если сеанс не закрывается, а приложение не отвечает,
		                             |можно снять его принудительно, однако есть риск
		                             |потерять изменения выполненные в фоновом задании!'") );
	Иначе
		Отбор = Новый Структура("УникальныйИдентификатор", Новый УникальныйИдентификатор(Идентификатор));
		МассивФоновыхЗаданий = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		Если МассивФоновыхЗаданий.Количество() <> 1 Тогда
			ВызватьИсключение( НСтр("ru = 'Фоновое задание не найдено на сервере!'") );
		ИначеЕсли МассивФоновыхЗаданий[0].Состояние <> СостояниеФоновогоЗадания.Активно Тогда
			ВызватьИсключение( НСтр("ru = 'Задание не выполняется, его нельзя отменить!'") );
		Иначе
			МассивФоновыхЗаданий[0].Отменить();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ОтменитьФоновоеЗадание()

// Функция СообщенияИОписанияОшибокФоновогоЗадания возвращает
// многострочную Строку содержащую Сообщения и ОписаниеИнформацииОбОшибке,
// если фоновое задание найдено по идентификатору и сообщения/ошибки есть.
//
// Параметры:
//  Задание      - Строка - УникальныйИдентификатор ФоновогоЗадания строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция СообщенияИОписанияОшибокФоновогоЗадания(Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	СвойстваФоновогоЗадания = ПолучитьСвойстваФоновогоЗадания(Идентификатор);
	Строка = "";
	Для каждого Сообщение Из СвойстваФоновогоЗадания.СообщенияПользователю Цикл
		Строка = Строка + ?(Строка = "",
		                    Сообщение,
		                    "
		                    |
		                    |" + Сообщение);
	КонецЦикла;
	Если ЗначениеЗаполнено(СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке) Тогда
		Строка = Строка + ?(Строка = "",
		                    СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке,
		                    "
		                    |
		                    |" + СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке);
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции // СообщенияИОписанияОшибокФоновогоЗадания()

// Процедура ОчиститьИсториюФоновыхЗаданий очищает таблицу
// хранения выполненных и выполняемых (в случае с серверным режимом) фоновых заданий.
//
Процедура ОчиститьИсториюФоновыхЗаданий() Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Состояние.ТаблицаФоновыхЗаданий = Неопределено;
	Иначе
		ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания();
		Идентификаторы = Новый Соответствие;
		Для каждого ФоновоеЗадание Из ТекущиеФоновыеЗадания Цикл
			Идентификаторы.Вставить(Строка(ФоновоеЗадание.УникальныйИдентификатор), 1);
		КонецЦикла;
		Индекс = Состояние.ТаблицаФоновыхЗаданий.Количество()-1;
		Пока Индекс >=0 Цикл
			Если Идентификаторы.Получить(Состояние.ТаблицаФоновыхЗаданий[Индекс].Идентификатор) <> 1 Тогда
				Состояние.ТаблицаФоновыхЗаданий.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
	КонецЕсли;
	ПроверитьТаблицуФоновыхЗаданий(Состояние.ТаблицаФоновыхЗаданий);
	ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ МЕТОДЫ ОБОБЩЕННОГО МЕНЕДЖЕРА ФОНОВЫХ ЗАДАНИЙ

// Функция ПроверитьТаблицуФоновыхЗаданий проверяет структуру ТаблицыЗначений
// для хранения выполненных/выполняемых фоновых заданий,
// и создает пустую таблицу, если есть различия.
//
// Параметры:
//  Таблица      - ТаблицаЗначений - таблица у которой будет проверяться структура.
//
// Возвращаемое значение:
//  Булево - когда Истина структура была правильная.
//
Функция ПроверитьТаблицуФоновыхЗаданий(Таблица)
	
	НоваяТаблица = Новый ТаблицаЗначений;
	НоваяТаблица.Колонки.Добавить("НаСервере", Новый ОписаниеТипов("Булево"));
	НоваяТаблица.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Ключ", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Начало", Новый ОписаниеТипов("Дата"));
	НоваяТаблица.Колонки.Добавить("Конец", Новый ОписаниеТипов("Дата"));
	НоваяТаблица.Колонки.Добавить("ИдентификаторРегламентногоЗадания", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Состояние", Новый ОписаниеТипов("СостояниеФоновогоЗадания"));
	НоваяТаблица.Колонки.Добавить("ИмяМетода", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Расположение", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("ОписаниеИнформацииОбОшибке", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("ПопыткаЗапуска", Новый ОписаниеТипов("Число"));
	НоваяТаблица.Колонки.Добавить("СообщенияПользователю", Новый ОписаниеТипов("Массив"));
	НоваяТаблица.Индексы.Добавить("Идентификатор, Начало");
	СтруктураПравильная = Истина;
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		Для каждого Колонка Из НоваяТаблица.Колонки Цикл
			// Будем проводить только проверку наличия имен колонок без проверки типов.
			Если Таблица.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				СтруктураПравильная = Ложь;
			КонецЕсли;
		КонецЦикла;
	Иначе
		СтруктураПравильная = Ложь;
	КонецЕсли;
	
	Если НЕ СтруктураПравильная Тогда
		Таблица = НоваяТаблица;
	КонецЕсли;
	
	Возврат СтруктураПравильная;
	
КонецФункции // ПроверитьТаблицуФоновыхЗаданий()

// ПроверитьНастройки служит для проверки/создания структуры свойств
// настроек, хранимых в структуре "Состояние" свойства Настройки.
//
// Возвращаемое значение:
//  Булево.
//
Функция ПроверитьНастройки(Настройки, Знач СоздатьНовые = Ложь)
	
	НоваяСтруктураНастроек = Новый Структура();
	НоваяСтруктураНастроек.Вставить("БлокировкаОбработкиРегламентныхЗаданий",                           Ложь);
	НоваяСтруктураНастроек.Вставить("ИмяПользователяДляЗапуска",                                        "");
	НоваяСтруктураНастроек.Вставить("ПарольПользователяДляЗапуска",                                     "");
	// Если нужно и можно, то при запуске клиентского приложения автоматически открывать сеанс обработки регламентных заданий.
	НоваяСтруктураНастроек.Вставить("АвтоматическиОткрыватьОтдельныйСеансОбработкиРегламентныхЗаданий", Ложь);
	// Если задания не обрабатываются или обработка "висит", уведомлять пользователя.
	НоваяСтруктураНастроек.Вставить("УведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий",     Ложь);
	//  Период, минут.
	НоваяСтруктураНастроек.Вставить("ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий",          15);
	
	СтруктураПравильная = Истина;
	Если ТипЗнч(Настройки) = Тип("Структура") Тогда
		Для каждого КлючИзначение Из НоваяСтруктураНастроек Цикл
			// Будем проводить только проверку наличия имен свойств без проверки типов.
			Если НЕ Настройки.Свойство(КлючИзначение.Ключ) Тогда
				СтруктураПравильная = Ложь;
			КонецЕсли;
		КонецЦикла;
	Иначе
		СтруктураПравильная = Ложь;
	КонецЕсли;
	Если СтруктураПравильная И НЕ (
	         ТипЗнч(Настройки.БлокировкаОбработкиРегламентныхЗаданий)                           = Тип("Булево") И
	         ТипЗнч(Настройки.ИмяПользователяДляЗапуска)                                        = Тип("Строка") И
	         ТипЗнч(Настройки.ПарольПользователяДляЗапуска)                                     = Тип("Строка") И
	         ТипЗнч(Настройки.АвтоматическиОткрыватьОтдельныйСеансОбработкиРегламентныхЗаданий) = Тип("Булево") И
	         ТипЗнч(Настройки.УведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий)     = Тип("Булево") И
	         ТипЗнч(Настройки.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий)          = Тип("Число" ) И
	                Настройки.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий           >= 1 И
	                Настройки.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий           <= 99 ) Тогда
		СтруктураПравильная = Ложь;
	КонецЕсли;	
	Если НЕ СтруктураПравильная И СоздатьНовые Тогда
		Настройки = НоваяСтруктураНастроек;
	КонецЕсли;
	
	Возврат СтруктураПравильная;
	
КонецФункции

// Функция ПолучитьСостояниеОбработкиРегламентныхЗаданий возвращает
// структуру, описывающую состояние обработки заданий.
//
Функция ПолучитьСостояниеОбработкиРегламентныхЗаданий()
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	Константы.СостояниеОбработкиРегламентныхЗаданий КАК ХранилищеЗначения
		|ИЗ
		|	Константы КАК Константы");
	Состояние = Запрос.Выполнить().Выгрузить()[0].ХранилищеЗначения.Получить();
	
	НоваяСтруктура = Новый Структура();
	НоваяСтруктура.Вставить("Настройки", Неопределено);
	//  Соответствие идентификаторов фоновых заданий идентификаторам регламентных заданий,
	//  тех фоновых заданий, которые были запущены на сервере вручную.
	НоваяСтруктура.Вставить("Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную", Новый Соответствие());
	// Хранение истории выполнения фоновых заданий.
	НоваяСтруктура.Вставить("ТаблицаФоновыхЗаданий",               Неопределено);
	НоваяСтруктура.Вставить("НомерСеанса",                         0);
	НоваяСтруктура.Вставить("НачалоСеанса",                        '00010101');
	НоваяСтруктура.Вставить("ИмяКомпьютера",                       "");
	НоваяСтруктура.Вставить("ИмяПриложения",                       "");
	НоваяСтруктура.Вставить("ИмяПользователя",                     "");
	НоваяСтруктура.Вставить("ИдентификаторОчередногоЗадания",      "");
	НоваяСтруктура.Вставить("НачалоОбработкиОчередногоЗадания",    '00010101');
	НоваяСтруктура.Вставить("ОкончаниеОбработкиОчередногоЗадания", '00010101');
	
	ПроверитьТаблицуФоновыхЗаданий(НоваяСтруктура.ТаблицаФоновыхЗаданий);
	
	СтруктураПравильная = Истина;
	Если ТипЗнч(Состояние) = Тип("Структура") Тогда
		Для каждого КлючИзначение Из НоваяСтруктура Цикл
			// Будем проводить только проверку наличия имен свойств без проверки типов.
			Если НЕ Состояние.Свойство(КлючИзначение.Ключ) Тогда
				СтруктураПравильная = Ложь;
			КонецЕсли;
		КонецЦикла;
	Иначе
		СтруктураПравильная = Ложь;
	КонецЕсли;
	Если НЕ СтруктураПравильная Тогда
		Состояние = НоваяСтруктура;
	КонецЕсли;
	ПроверитьНастройки(Состояние.Настройки, Истина);
	
	Возврат Состояние;
	
КонецФункции

// Процедура ОбновитьСостояниеОбработкиРегламентныхЗаданий() сохраняет
// в константе СостояниеОбработкиРегламентныхЗаданий переданное состояние.
//
// Параметры:
//  Состояние - Структура - изменённое значение функции
//                 ПолучитьСостояниеОбработкиРегламентныхЗаданий().
//  ОбновитьНастройки - Булево - если Ложь, настройки не обновляются.
//
Процедура ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние, ОбновитьНастройки = Ложь)
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("Константа.СостояниеОбработкиРегламентныхЗаданий");
		Элемент.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		ТекущееСостояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
		ЗаполнитьЗначенияСвойств(ТекущееСостояние, Состояние, , ?(ОбновитьНастройки, Неопределено, "Настройки"));
		Константы.СостояниеОбработкиРегламентныхЗаданий.Установить(Новый ХранилищеЗначения(ТекущееСостояние));
		ЗафиксироватьТранзакцию();
	Исключение
		ОписаниеОшибки = ОписаниеОшибки();
		ОтменитьТранзакцию();
		ВызватьИсключение(ОписаниеОшибки);
	КонецПопытки;
	
КонецПроцедуры // ОбновитьСостояниеОбработкиРегламентныхЗаданий()

// Процедура ОбработатьРегламентноеЗадание предназначена
// только для режима "файл-сервер", используется в процедуре
// ОбработатьРегламентныеЗадания()
// 
// Параметры:
//  Состояние    - Структура.
//  Задание      - РегламентноеЗадание.
//  ЗапускВручную - Булево.
//  МоментЗапуска - Неопределено, Дата(дата и время).Устанавливает значение, к момент запуска.
//  ИдентификаторФоновогоЗадания - Строка - идентификатор запущенного фонового задания.
//
Процедура ОбработатьРегламентноеЗадание(Знач Состояние,
                                        Знач Задание,
                                        Знач ЗапускВручную = Ложь,
                                        Знач МоментЗапуска = Неопределено,
                                        ИдентификаторФоновогоЗадания = "")

	ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(Задание);

	ИмяМетода = Задание.Метаданные.ИмяМетода;
	НаименованиеФоновогоЗадания = ?(ЗапускВручную,
	                                СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Запуск вручную: %1'"),
	                                                                                        ПредставлениеРегламентногоЗадания(Задание)),
	                                "");

	МоментЗапуска = ?(ТипЗнч(МоментЗапуска) <> Тип("Дата") ИЛИ НЕ ЗначениеЗаполнено(МоментЗапуска),
	                  ТекущаяДата(),
	                  МоментЗапуска);
	Таблица = Состояние.ТаблицаФоновыхЗаданий;
	// Создадим новое фоновое задание в таблице.
	СвойстваФоновогоЗадания = Таблица.Вставить(0);
	СвойстваФоновогоЗадания.Идентификатор  = Строка(Новый УникальныйИдентификатор());
	ИдентификаторФоновогоЗадания = СвойстваФоновогоЗадания.Идентификатор;
	СвойстваФоновогоЗадания.ПопыткаЗапуска = ?(СвойстваПоследнегоФоновогоЗадания <> Неопределено И
	                                           СвойстваПоследнегоФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно,
	                                           СвойстваПоследнегоФоновогоЗадания.ПопыткаЗапуска + 1,
	                                  1);
	СвойстваФоновогоЗадания.Наименование   = НаименованиеФоновогоЗадания;
	СвойстваФоновогоЗадания.ИдентификаторРегламентногоЗадания
	                                       = Строка(Задание.УникальныйИдентификатор);
	СвойстваФоновогоЗадания.Расположение = "\\" + ИмяКомпьютера();
	СвойстваФоновогоЗадания.ИмяМетода    = ИмяМетода;
	СвойстваФоновогоЗадания.Состояние    = СостояниеФоновогоЗадания.Активно;
	СвойстваФоновогоЗадания.Начало       = МоментЗапуска;
	// Выполним метод, как фоновое задание.
	СтрокаПараметров = "";
	Индекс = Задание.Параметры.Количество()-1;
	Пока Индекс >= 0 Цикл
		Если НЕ ПустаяСтрока(СтрокаПараметров) Тогда
			СтрокаПараметров = СтрокаПараметров + ", ";
		КонецЕсли;
		СтрокаПараметров = СтрокаПараметров + "Задание.Параметры[" + Индекс + "]";
		Индекс = Индекс - 1;
	КонецЦикла;
	//
	ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	ПолучитьСообщенияПользователю(Истина);
	Попытка
		Выполнить("" + ИмяМетода + "(" + СтрокаПараметров + ");");
		СвойстваФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.Завершено;
	Исключение
		СвойстваФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно;
		СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	// Зафиксируем окончание выполнения метода и обновим таблицу во временном хранилище.
	СвойстваФоновогоЗадания.Конец = ТекущаяДата();
	СвойстваФоновогоЗадания.СообщенияПользователю = ПолучитьСообщенияПользователю(Истина);
	
	ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
	
	
КонецПроцедуры // ОбработатьРегламентноеЗадание()
